//
// Created by Sowmya Parameshwara on 9/30/16.
//
/**
 *
Serial code which was parallelised :
Loop 1 : for (norm = 0; norm < N - 1; norm++) {
            Loop 2 : for (row = norm + 1; row < N; row++) {
                                     multiplier = A[row][norm] / A[norm][norm];
                      Loop 3 : for (col = norm; col < N; col++) {
                                            A[row][col] -= A[norm][col] * multiplier;
                                     }
                                     B[row] -= B[norm] * multiplier;
                           }
                }


 *  1) There exists a data dependency across iterations of Loop 1, hence it was not parallelised.
 *  2) There is no data dependency across iterations of Loop 2, hence it was parallelised using data parallelism.
 *  3) A parallel directive is added before loop 2 mentioning the shared and private variables.
 *  4) Matrix A, vector B, outer loop index variable 'norm' and N are declared as shared variables.
 *  5) Index row, col and multiplier are private variable.
 *  6) The number of threads and scheduling is the system default.
 *  7) General idea, In first iteration of loop 1 we need to initialise all entries in column[0] starting from row[1] to ‘0’. This happens in loop 2
 *     by “Add to one row a scalar multiple of another” such that corresponding column value becomes 0. This operation happens in parallel where all
 *     the threads performs this process on different rows. After this is done, the next column will be picked up in loop 1 and the operation is repeated.
 *     Once the matrix is in row echelon form, backsubsitution is performed to calculate the result.
 *
 *  Steps to compile and execute :
 *  1) gcc -o GaussOpenMP GaussOpenMP.c -fopenmp
 *  2) ./GaussOpenMP 10 4   <Argument 1 : Size of matrix, Argument 2 : Random seed value.
 *
 */


#include <omp.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/times.h>
#include <sys/time.h>

#define MAXN 20000  /* Max value of N */
int N;
/* Matrices and vectors */
volatile float A[MAXN][MAXN], B[MAXN], X[MAXN];


void parameters(int argc, char **argv);
void initializeInputs();
void printInputs();
void printX();
void backSubstitution();
void gaussOpenMP();



int main(int argc, char **argv) {
    /* Timing variables */
    struct timeval etStart, etStop;  /* Elapsed times using gettimeofday() */
    struct timezone dummyTz;
    unsigned long long startTime, endTime;

    /* Process program parameters */
    parameters(argc, argv);
    /* Initialize A and B */
    initializeInputs();
    /* Print input matrices */
    printInputs();
    /**Get time before starting guassian algorithm */
    gettimeofday(&etStart, &dummyTz);
    /* Guassian threadP algorithm*/
    gaussOpenMP();
    /**Get time after completing guassian algorithm*/
    gettimeofday(&etStop, &dummyTz);
    /* Display output */
    printX();
    startTime = (unsigned long long)etStart.tv_sec * 1000000 + etStart.tv_usec;
    endTime = (unsigned long long)etStop.tv_sec * 1000000 + etStop.tv_usec;
    /* Display timing results */
    printf("\nTotal time = %g ms.\n",(float)(endTime - startTime)/(float)1000);

    exit(0);

}


/* Set the program parameters from the command-line arguments
 * argv[1] : Matrix Size
 * argv[2] : Random Seed
 * r*/
void parameters(int argc, char **argv) {
    int seed = 0;
  if(argc == 3){
        seed = atoi(argv[2]);
        srand(seed);

        N = atoi(argv[1]);
        if (N < 1 || N > MAXN) {
            printf("N = %i is out of range.\n", N);
            exit(0);
        }
    } else {
        printf("Usage: %s <matrix_dimension> [random seed]  \n",
               argv[0]);
        exit(0);
    }
    /* Print parameters */
    printf("\nMatrix dimension N = %i. Seed = %d .\n", N,seed);
}

/* Initialize A and B (and X to 0.0s) */
void initializeInputs() {
    int row, col;

    printf("\nInitializing...\n");
    for (col = 0; col < N; col++) {
        for (row = 0; row < N; row++) {
            A[row][col] = (float)rand() / 32768.0;
        }
        B[col] = (float)rand() / 32768.0;
        X[col] = 0.0;
    }

}

/* Print input matrices A[N][N] and B[N] generated by randomiser */
void printInputs() {
    int row, col;

    if (N < 10) {
        printf("\nA =\n\t");
        for (row = 0; row < N; row++) {
            for (col = 0; col < N; col++) {
                printf("%5.2f%s", A[row][col], (col < N-1) ? ", " : ";\n\t");
            }
        }
        printf("\nB = [");
        for (col = 0; col < N; col++) {
            printf("%5.2f%s", B[col], (col < N-1) ? "; " : "]\n");
        }
    }
}

/**
 * Prints X coefficient values
 */
void printX() {
    int row;

    if (N < 100) {
        printf("\nX = [");
        for (row = 0; row < N; row++) {
            printf("%5.2f%s", X[row], (row < N-1) ? "; " : "]\n");
        }
    }
}



/**
 * Use backward substitution technique to calculate X values.
 * Say X0, X1, X2 .....XN needs to be calculated. This method starts calculating XN and on completion
 * uses this value to calculate X(N-1) and so on goes backwards.
 */
void backSubstitution(){
    int norm, row, col;
    /* Back substitution */
    for (row = N - 1; row >= 0; row--) {
        X[row] = B[row];
        for (col = N-1; col > row; col--) {
            X[row] -= A[row][col] * X[col];
        }
        X[row] /= A[row][row];
    }

}

/**
 * This method does gaussian elimination by first reducing the matrix to upper triangular matrix.
 * This method uses pragma open mp for loop parallelism for the first inner 'for loop'.
 * The number of threads are assigned as per system environment variable.
 * After the matrix is reduced to row echelon form backSubstitution is done to determine X coefficients.
 */
void gaussOpenMP() {
    int norm, row, col;  /* Normalization row, and zeroing
			* element row and col */
    float multiplier;

    printf("Computing Parallely using open mp.\n");

    /* Gaussian elimination using openmp data parallelism*/
    for (norm = 0; norm < N - 1; norm++) {
    #pragma omp parallel for shared(A,B,norm,N) private(row,multiplier,col) default(none)
        for (row = norm + 1; row < N; row++) {
      /*    int tid = omp_get_thread_num();
            printf("Hello World from thread = %d\n", tid);*/
            multiplier = A[row][norm] / A[norm][norm];
            for (col = norm; col < N; col++) {
                A[row][col] -= A[norm][col] * multiplier;
            }
            B[row] -= B[norm] * multiplier;
        }
    }

    /* Backward substitution on row echelon form matrix to determine cooefficients
     */
    backSubstitution();
}


